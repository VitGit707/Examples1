 // Example013_RecusionAlgoritm РЕКУРСИЯ!!!
// Console.WriteLine("Example013_RecusionAlgoritm !!!");

/* Theori ДВУМЕРНЫЙ МАССИВ

/* ЗАПОМНИМ КАК ПИШЕТСЯ ДВУМЕРНЫЙ МАССИВ:

// int[,] matrix = new int[3, 4];
// Обязат пишем тип данных int
// Квадр скобки обязат с запятой внутри [,] 
// Наименование массива matrix 
// Оператор присваивания = 
// Условия new 
// Тип данных int
// В скобках [Строки 3 либо matrix.GetLength(0), Столбцы 4 либо matrix.GetLength(1)] 
*/

/*string[,] table = new string[2, 5];
// // String.Empty - Инициализ строк происх с пом этой константы
// // table [0, 0] table [0, 1] table [0, 2] table [0, 3] table [0, 3]
// // table [1, 0] table [1, 1] table [1, 2] table [1, 3] table [1, 4]

table[1, 2] = "слово"; // мы указ наим массива table [1 - кол строк, 2 кол столбцов] = дальше указ обыч перменую

for (int rows = 0; rows < 2; rows++) // Здесь нам потребуется цикл в цикле
{  // для распечатки нашего массива потребуется 2 цикла (цикл в цикле)
    for (int columns = 0; columns < 5; columns++)
    {        
        Console.WriteLine($"-{table[rows, columns]}-");
    }  
}

// Опишем метод, который будет печатать двумерную матрицу
// и заполнять ее числами
void PrintArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0); i++)  // Вместо i < 3
    {
        for (int j = 0; j < matr.GetLength(1); j++) // Вместо j < 4
        {
            Console.Write($"{matr[i, j]} "); 
        }
        Console.WriteLine();
    }

}

// Опишем доп метод, который будет заполнять нашу матрицу 
// случайными числами

void FillArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0); i++)
    {
        for (int j = 0; j < matr.GetLength(1); j++)
        {
            matr[i, j] = new Random().Next(1, 10); // [1; 10) Пишем через использв генерато псевдослуч чисел
        }
    }
}

int[,] matrix = new int[3, 4];

PrintArray(matrix); //Снач при распечатке убедимся что у нас распечатыв 0 нолики, после этого
FillArray(matrix); //После этого сделаем FillArray в качест аргум переда наш массив (matrix)
Console.WriteLine();
PrintArray(matrix);// Снова распечатаем
*/
/* Как представить черно-белое изображение

// x-1, y-1   x-1, y   x-1, y+1
//  x , y-1     x, y     x, y+1
// x+1, y-1   x+1, y   x+1, y+1

// int[,] public = new int[,]
// 0 - незакрашенный пиксель
// 1 - закрашенный пиксель
// Как закрасить область?
// Пример рекурсии: КАК ЗАКРАСИТЬ черно-белое изображение:
// int[,] public = new int[,]
int[,] pic = new int[,]
{
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};

// Опишем метод, выводящий картинку
void PrintImage(int[,] image)
{
    for (int i = 0; i < image.GetLength(0); i++) // Вместо i < 3 можем указазать i < image.GetLength(0)
    {
        for (int j = 0; j < image.GetLength(1); j++) // Вместо j < 4 можем указазать j < image.GetLength(1)
        {
            // Console.Write($"{image[i, j]} ");
            if(image[i,j] == 0) Console.Write($" "); // Если image[i,j] совпадает == с 0 Мы печат пробел Console.Write($" ")
            else Console.Write($"+");
        
        }
        Console.WriteLine();
    }

}

PrintImage (pic); // Выведим нашу картинку "ПАЛЕЦ ВВЕРХ" в консоль

// Опишем метод void FillImage - ЗАКРАШИВАЮЩИЙ НАШУ КАРТИНКУ 
void FillImage(int row, int col) // В качеств аргум возьмем нач пози- 
{   //ции строки и столбца (int row, int col) c котор начнем раскраску                       
    if (pic[row, col] == 0) // провер условие: Если текущий пиксель row, col] равен 0 т.е. НЕЗАКРАШЕН
    {
        pic[row, col] = 1; // в этом случае мы) его красим присваиваем ему 1
        FillImage (row -1, col); //сначала мы договор подниматься от текущ пикселя на строчку выше
        FillImage (row , col -1);//после мы договор в той-же строке идти влево, поз столбика меняем на -1
        FillImage (row + 1, col);//после мы договорились идти вниз на след строку
        FillImage (row, col + 1);//на послед этапе мы договор идти вправо на другой столбец
    }
}

PrintImage(pic); 
FillImage(13, 13);
PrintImage(pic);
*/

// РЕКУРСИЯ - ЭТО ФУНКЦИЯ, КОТОРАЯ ВЫЗЫВАЕТ САМА СЕБЯ

/* ФАКТОРИАЛ
// 5! = 5*4*3*2*1
//      5*4!
//        4*3!
//          3*2!

// Пример Рекурсии:  ВЫЧИСЛЕНИЕ ФАКТОРИАЛА
double Factorial (int n)
{
    // 1! = 1
    // 0! = 1
    if(n == 1) return 1;
    else return n * Factorial(n-1); // Factorial(n-1) - Факториал предыдущего числа
}
for (int i = 1; i<15; i++)
{
     Console.WriteLine($"{i}! = {Factorial(i)}"); 
}
*/

/* Пример Рекурсии ВЫЧИСЛЕНИЕ ЧИСЕЛ ФИБОНАЧИ

// f(1) = 1
// f(2) = 1
// f(n) = f(n-1) + f(n-2)
 double Fibonacci (int n) // возвращается  integer-значение
{
    if(n==1 || n == 2) return 1;
    else return Fibonacci (n - 1) + Fibonacci (n - 2);
}

for (int i = 1; i < 10; i++)
{
    Console.WriteLine(Fibonacci(i));
}
*/

/* Давайте попробуем посчитать первые 50 чисел ФИБОНАЧЧИ так,
// чтобы возвращалось double-значение.

double Fibonacci (int n)
{
    if(n==1 || n == 2) return 1;
    else return Fibonacci (n - 1) + Fibonacci (n - 2);
}

for (int i = 1; i < 50; i++)
{
    Console.WriteLine($"f({i}) = {Fibonacci(i)}");
}
*/
/*ИТОГИ 
* ЦИКЛОВ МНОГО НЕ БЫВАЕТ И ДВУМЕРНЫЕ МАССИВЫ ТОМУ ПОДТВЕРЖДЕНИЕ
* МАССИВОВ МНОГО НЕ БЫВАЕТ
* УГЛУБЛЕНИЕ В МЕТОДЫ И ПРАКТИЧЕСКАЯ РЕКУРСИЯ
*/

// Урок 7. Дополнительная лекция. Рекурсия продолжение
/* Игра в пирамидки
// Решаем с помощью рекурсии

void Towers(string with = "1", string on = "3", string some = "2", int count = 4)
{
    if (count > 1) Towers(with, some, on, count - 1);
    Console.WriteLine($"{with} >> {on}");
    if (count > 1) Towers(some, on, with, count - 1);
}
Towers();
*/

/* Задача 2 Обход разных структур
string emp = String.Empty;
string[] tree = { emp, "/", "*", "10", "-", "+", emp, emp, "4", "2", "1", "3" };
//                0    1    2     3    4    5    6    7    8    9    10   11  
void InOrderTraversal(int pos = 1)
{
    if (pos <tree.Length)
    {
        int left = 2 * pos;
        int right = 2 * pos +1;
        if (left < tree.Length && !String.IsNullOrEmpty(tree[left])) InOrderTraversal(left);
        Console.WriteLine(tree[pos]);
        if (right < tree.Length && !String.IsNullOrEmpty(tree[left])) InOrderTraversal(right);
    }
}
InOrderTraversal();
*/
